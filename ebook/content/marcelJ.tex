\section{Advantages}
Since Riak is a distributed database there are different advantages making Riak special. Riak focuses on high availability, easy scalability and data safety. This is achieved through the distribution of the database across several nodes. \cite{Basho.01.04.2017}
The main advantages of the distributed approach are:
\begin{itemize}
	\item Installation
	\item Scalability
	\item Availability
	\item Interaction
	\item Error management
\end{itemize}
In the following subsections this concepts will be described in more detail. 
\subsection{Installation}
The installation of Riak is easy and straight forward. Riak is available for various Linux distributions and Mac OS X. There is an Dabian package for Ubuntu, delivered through bashos web page (HTTP://docs.Bashocom/riak/kv/2.2.2/downloads/). This package can be easily installed with Ubuntus package manager. After the setup you are ready to go. With the command \textit{"riak start"} a Riak cluster with one node and the standard settings is started. \cite{Basho.01.04.17c}
\subsection{Scalability}
Riak uses a distributed cluster approach built up of several nodes which makes it highly scalable. If there is a need for higher performance or stability there could be easily added several nodes to the cluster. This can be done even when the database is running. 
Before a node can be added to a cluster it needs to be started with the \textit{"riak start"} command. After the node is running it can be added to a cluster with the \textit{"riak cluster join"} command. \cite{Basho.01.04.17b}
\subsection{Availability}
A special feature of Riak is its high availability Riak uses a masterless system resulting in no single point of failure. If all nodes fail except one this last node will take all of the responsibilities of the other nodes. The cluster gets very slow, but it stays available and responsive.
\subsection{Interaction}
Another unique selling point of Riak is its native HTTP 1.1 API. This API is designed as RESTful Web service. Create, read, update and delete (CRUD) actions can be performed over the corresponding HTTP methods. This makes Riak a very flexible and handy database. 
Besides that Riak guarantees client support for common programming languages like Java, Ruby, Python, C\#, Node.js, PHP, Erlang and Go.  
\subsection{Error management}
If multiple clients can write concurrently and potentially to the same key it is very likely that errors could happen. Therefore Riak has to use an error management. There is an logical approach called vector clock which abstracts the states of a data set on an analogous clock to track the history of updates to a value. If the data is corrupted through conflict writes, it can be restored through this mechanism. 
\section{Disadvantages}
The distributed approach of Riak a very beneficial and useful as the previous section shows. But besides this advantages there are some downsides as well. Several nodes and the masterless concept lead to various problems like:
 \begin{itemize}
 	\item Inconsistency
 	\item Vector-clocks
 	\item No rollbacks
 \end{itemize}
 In the next subsections we will dig a little bit deeper in those problems. \cite{FHKoln.01.04.17}
 \subsection{Inconsistency}
 The main problem of highly-available, clustered systems like Riak is the validity of data sets. Due to the fact that there are no ACID transactions data sets can get inconsistent. There is no mechanism guaranteeing the transfer of a consistent state into another. This results in conflicting responses and anomalies which have to be handled.  
 \subsection{Vector-clocks}
 Although the error management concept of Riak is very reasoned the vector-clock system is leading to some difficulties. It is possible that Riak creates different values for an object on various nodes. These values are called siblings. This could lead to inconsistency and conflicts.
 \subsection{No rollbacks}
 Despite Riaks sophisticated error management system there is no way to completely restore a dataset. This is due to a missing rollback and commit mechanism. This means if you have done any change to the data it is irreversible.  
 \newpage
 \section{Use Cases}
 As you may have noticed, Riak is a quite special database solution. There are several use cases Riak is perfectly suited for. The first one described in here is session data. This means the usage of Riak for storing users and sessions into a Riak database. This data is usually used to save data about the applications connection with the user. Therefore it is very important to have this data highly available.
 Another common use case for Riak are chat and messenger applications. Traditional rational databases are not suited for the heterogeneous data messaging applications bring along. Therefore key value databases like Riak are more efficient way to save those data. Furthermore the highly-available, low-latency data architecture of Riak provides a good base for messaging apps which are always available.
 The next point is business continuity. This means applications which should not have a downtime of only several minutes. With Riak you can scale and maintain such applications even if the database is running. This is why Riak fits perfectly well to this use case.
 The last point described in this section is the usage of Riak for saving content and documents. This documents are highly unstructured because there are a huge amount of different data like pdf files, log files, emails, chat history, books, articles and videos. With Riak all of this data can be saved in a proper manner. There is no overload  as in a rational database. \cite{Basho.01.04.17}  
 
 To conclude with, Riak is used by several companies in the gaming, retail, telecommunications and transportation area as high available and scalable database. Well known companies which use Riak are Uber, Rovio, Best Buy, Xing and Symantec. \cite{Basho.01.04.17b}
 
 \newpage